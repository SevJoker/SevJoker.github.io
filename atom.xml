<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Seven&#39;s Blog</title>
  
  <subtitle>seven</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://sevjoker.github.io/"/>
  <updated>2019-10-13T16:14:02.050Z</updated>
  <id>http://sevjoker.github.io/</id>
  
  <author>
    <name>SevenDing</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>消失的panic</title>
    <link href="http://sevjoker.github.io/2019/10/14/gopanic/"/>
    <id>http://sevjoker.github.io/2019/10/14/gopanic/</id>
    <published>2019-10-13T16:08:08.000Z</published>
    <updated>2019-10-13T16:14:02.050Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --><h1 id="消失的panic"><a href="#消失的panic" class="headerlink" title="消失的panic"></a>消失的panic</h1><h2 id="现场"><a href="#现场" class="headerlink" title="现场"></a>现场</h2><p><img src="/2019/10/14/gopanic/1.png" alt="Alt text"></p><p><img src="/2019/10/14/gopanic/2.png" alt="Alt text"><br><img src="/2019/10/14/gopanic/3.png" alt="Alt text"><br><img src="/2019/10/14/gopanic/4.png" alt="Alt text"></p><ul><li>线上运行142行 报panic</li><li>线下模拟不复现</li><li>线上模拟不复现</li></ul><h2 id="复现之旅"><a href="#复现之旅" class="headerlink" title="复现之旅"></a>复现之旅</h2><ul><li>并发压测尝试后发现会出现这种case</li></ul><h2 id="问题发现之旅"><a href="#问题发现之旅" class="headerlink" title="问题发现之旅"></a>问题发现之旅</h2><h3 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h3><blockquote><p>第一认知 以为panic的原因是MultiDayTypeConfig 或者 MultiDayTypeConfig.d 为nil，故在程序中打印这两个值，看是否有nil，并发压测复现问题未曾发现log中有任何 nil输出</p></blockquote><p>失败</p><h3 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h3><blockquote><p>怀疑是否会有并发读写该值的情况导致nil，故将程序中所有关于该值得写入口注释（除了程序启动时），并发测试，panic依旧</p></blockquote><p>失败</p><h3 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h3><blockquote><p>因为涉及并发，考虑可能会牵扯数据竞争问题, 所以编译时加入 <code>-race</code> 参数看改值是否存在竞争情况，并发模拟，data race log比较多，过滤筛选并未发现 MultiDayTypeConfig相关的日志，而且加race参数后 协程数量不可超过8192，此时未复现问题，（log中有 不少关于 context.TripCountry 的日志）</p></blockquote><p>失败</p><h3 id="尝试4"><a href="#尝试4" class="headerlink" title="尝试4"></a>尝试4</h3><blockquote><p>抱着试一试的心态，当时以为会不会是 interface 在层层函数传递时候发生了意料之外的情况，将函数改写如下<br><img src="/2019/10/14/gopanic/5.png" alt="Alt text"><br>并发模拟 未复现问题 （amazing）</p></blockquote><p>瞎猫碰到死耗子</p><h3 id="尝试5"><a href="#尝试5" class="headerlink" title="尝试5"></a>尝试5</h3><blockquote><p>认为这个毫无道理可言，而且这么改写也不科学，继续挖。<br>看着data race的log，突发尝试，将context的TripCountry得修改放在并发外<br>并发模拟尝试，未复现问题</p></blockquote><p>bug 修复</p><blockquote><p>But 可是并发写入string 理论上并不会crash，而且最终的nil造成原因我们还是一无所知</p></blockquote><h2 id="黎明前"><a href="#黎明前" class="headerlink" title="黎明前"></a>黎明前</h2><h3 id="意外之喜"><a href="#意外之喜" class="headerlink" title="意外之喜"></a>意外之喜</h3><blockquote><p>偶然尝试 在<code>GetDayTypeByMemory</code> 中添加recover 尝试捕获第一现场，在recover中打印 MultiDayTypeConfig.d MultiDayTypeConfig 及 countryCode，将外层的recover 去除，目的是为了并发下打印污染，希望能直接看到panic现场内容<br>意外发现 recover中的 fmt.Println 二次panic<br>分开打印，居然发现是打印 countryCode 的时候 panic<br>What the fxxk！！！！<br><img src="/2019/10/14/gopanic/6.png" alt="Alt text"></p></blockquote><h3 id="漫漫猜测路"><a href="#漫漫猜测路" class="headerlink" title="漫漫猜测路"></a>漫漫猜测路</h3><p>大概了解了一下golang string 运行时底层本质上是这么一个结构<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type StringHeader struct &#123;</span><br><span class="line">        Data uintptr</span><br><span class="line">        Len  int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>Data代表string数据的首地址，len 代表字节长度</p></blockquote><h4 id="猜测1"><a href="#猜测1" class="headerlink" title="猜测1"></a>猜测1</h4><p>怀疑在并发写入这个string的时候，协程1传递到函数的值 被协程2修改导致协程1 的string被gc（理论上这个时候协程1的值有句柄在函数栈上，不过数据存在堆上，到底会不会被gc，值得试一下），线下写了一个并发写入string 主动调用gc的 demo<br><img src="/2019/10/14/gopanic/7.png" alt="Alt text"></p><p>并不能复现 panic<br>失败</p><h4 id="继续尝试"><a href="#继续尝试" class="headerlink" title="继续尝试"></a>继续尝试</h4><p>考虑是否可以打印 countryCode 的首地址，看是否有变化及差异。<br>代码如下所示<br><img src="/2019/10/14/gopanic/8.png" alt="Alt text"><br>复现问题后输出如下所示<br><code>-------------------------------------data:00000000-------len:2</code></p><p>OMG！！！<br>数据地址为空？ 长度为不为0 ？？？？</p><blockquote><p>这个地方就解释了为啥 fmt 也会nil panic<br>这个string 只要涉及取值操作就回 nil panic</p></blockquote><h4 id="线下模拟"><a href="#线下模拟" class="headerlink" title="线下模拟"></a>线下模拟</h4><p><img src="/2019/10/14/gopanic/9.png" alt="Alt text"></p><p>并发写入struct的string再输出<br>模拟失败（中间尝试切换go版本保证线下线上环境一致均失败）<br><code>ok panic</code></p><blockquote><p>中间还有个小误会，开始用1.8 跑的时候 跑了好久没panic 以为版本差异会导致panic<br>后来才发现 1.8 只不过稳定的时候长很多，panic该来还是会来的</p></blockquote><h4 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h4><h5 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h5><p><img src="/2019/10/14/gopanic/10.png" alt="Alt text"><br><img src="/2019/10/14/gopanic/11.png" alt="Alt text"></p><blockquote><p>Len Data 分开赋值 多条指令。并发场景并不安全<br>简化版本处理</p></blockquote><p><img src="/2019/10/14/gopanic/12.png" alt="Alt text"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>并发场景赋值的不安全性</p><h2 id="学习巩固知识点"><a href="#学习巩固知识点" class="headerlink" title="学习巩固知识点"></a>学习巩固知识点</h2><ul><li>golang 的 string</li><li>golang gc</li><li>堆与栈</li><li>golang data race</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;消失的panic&quot;&gt;&lt;a href=&quot;#消失的panic&quot; class=&quot;headerlink&quot; title=&quot;消
      
    
    </summary>
    
      <category term="技术" scheme="http://sevjoker.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="golang" scheme="http://sevjoker.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>myself</title>
    <link href="http://sevjoker.github.io/2019/10/13/myself/"/>
    <id>http://sevjoker.github.io/2019/10/13/myself/</id>
    <published>2019-10-13T15:31:04.000Z</published>
    <updated>2019-10-13T16:05:17.181Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --><h1 id="myself"><a href="#myself" class="headerlink" title="myself"></a>myself</h1><blockquote><p>当我回首往事的时候，不会因虚度年华而悔恨，也不会因碌碌无为而羞愧！</p></blockquote><h2 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h2><blockquote><p><a href="https://www.processon.com/view/link/5da344f7e4b0ece757c9c6a0" target="_blank" rel="noopener">https://www.processon.com/view/link/5da344f7e4b0ece757c9c6a0</a></p></blockquote><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>我一直崇尚自由，然鹅却浑身不自在，或许应该做出点改变。。。。。也许真的自律方可自由<br>要有靶心才能射箭，想了下，我想做个什么样的人，我希望自己能做一个有独立思想的人，对事对物都有自己的认识，有自己的底线，在这个认识和底线下我是自由的</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;myself&quot;&gt;&lt;a href=&quot;#myself&quot; class=&quot;headerlink&quot; title=&quot;mysel
      
    
    </summary>
    
      <category term="生活" scheme="http://sevjoker.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="自省" scheme="http://sevjoker.github.io/tags/%E8%87%AA%E7%9C%81/"/>
    
  </entry>
  
  <entry>
    <title>http长连接</title>
    <link href="http://sevjoker.github.io/2019/10/13/%E9%95%BF%E8%BF%9E%E6%8E%A5/"/>
    <id>http://sevjoker.github.io/2019/10/13/长连接/</id>
    <published>2019-10-13T14:40:49.000Z</published>
    <updated>2019-10-13T14:44:27.617Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --><h1 id="http长连接"><a href="#http长连接" class="headerlink" title="http长连接"></a>http长连接</h1><h4 id="http特点"><a href="#http特点" class="headerlink" title="http特点"></a>http特点</h4><ol><li>简单快速</li><li>灵活</li><li>无连接 *<ul><li>限制每次连接只处理一个请求</li><li>用完即断 （后期加入）</li></ul></li><li>无状态 *<ul><li>协议对于事务处理没有记忆能力</li><li>每个请求都是独立的</li><li>借助 Cookie Session 完成上下文联系</li></ul></li><li>支持B/S(Browser/Server) 及C/S(Client/Serve)模式</li></ol><p><strong>Q 无连接的特性如何实现 长连接</strong></p><h4 id="网络协议分层简介"><a href="#网络协议分层简介" class="headerlink" title="网络协议分层简介"></a>网络协议分层简介</h4><p><img src="/2019/10/13/长连接/0.png" alt="Alt text"></p><h4 id="http-之-Keep-alive"><a href="#http-之-Keep-alive" class="headerlink" title="http 之 Keep-alive"></a>http 之 Keep-alive</h4><blockquote><p>上图我们可以知道http 基于 tcp 协议。虽然http本身是无连接的，不过tcp是协议是完全面向连接具有强可靠性。故可以通过复用tcp连接的方式实现所谓的http长连接<br>即HTTP长连接和短连接本质上是TCP长连接 和 短连接（握手说句话再见）</p></blockquote><h4 id="实验模型"><a href="#实验模型" class="headerlink" title="实验模型"></a>实验模型</h4><p>基于 nginx 的 keepAlive 实验<br><img src="/2019/10/13/长连接/1.png" alt="Alt text"></p><blockquote><p>该场景下有两个地方可以完成http长连接配置<br>针对10.10.7.179 &lt; - &gt; 10.9.71.78 进行分析</p></blockquote><h4 id="抓包分析"><a href="#抓包分析" class="headerlink" title="抓包分析"></a>抓包分析</h4><p>看包 说话</p><blockquote><p>短连接 不复用<br>demo_no_keepalive_simple.cap<br><img src="/2019/10/13/长连接/2.png" alt="Alt text"></p></blockquote><blockquote><p>长连接 复用tcp连接<br>demo_keepalive_simple.cap<br><img src="/2019/10/13/长连接/3.png" alt="Alt text"></p></blockquote><h4 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h4><p><img src="/2019/10/13/长连接/4.png" alt="Alt text"></p><h4 id="nginx-http长连接-配置"><a href="#nginx-http长连接-配置" class="headerlink" title="nginx http长连接 配置"></a>nginx http长连接 配置</h4><blockquote><p>netstat -nat | grep -i “10.9.71.78:6601”<br>观察不同配置下tcp连接的不同变化</p></blockquote><p>upstream module 中<br><img src="/2019/10/13/长连接/5.png" alt="Alt text"></p><p>location module 中<br><img src="/2019/10/13/长连接/6.png" alt="Alt text"></p><p>http module 中<br><img src="/2019/10/13/长连接/7.png" alt="Alt text"><br>按需配置</p><p>####性能对比</p><blockquote><p>统一 nginx 单worker, server为简单的hello world服务</p></blockquote><ol><li>禁用长连接<br><img src="/2019/10/13/长连接/8.png" alt="Alt text"></li><li>启用http 长连接<br><img src="/2019/10/13/长连接/9.png" alt="Alt text"></li></ol><p>性能差异 达到 70%+ （这个压测结果应该算是极限差距吧。按server耗时与传输占比来算）</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况<br>WEB网站的http服务一般都用短链接<br>选则法则：面向”用户多少”选择</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;http长连接&quot;&gt;&lt;a href=&quot;#http长连接&quot; class=&quot;headerlink&quot; title=&quot;htt
      
    
    </summary>
    
      <category term="技术" scheme="http://sevjoker.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="golang" scheme="http://sevjoker.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>hexo踩坑</title>
    <link href="http://sevjoker.github.io/2019/10/13/hexo%E8%B8%A9%E5%9D%91/"/>
    <id>http://sevjoker.github.io/2019/10/13/hexo踩坑/</id>
    <published>2019-10-13T13:51:09.000Z</published>
    <updated>2019-10-13T15:30:43.550Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><blockquote><p>年关将至，目标还差的很远啊~~~<br>简单整理一下这些年自己的经历画成图谱（后续完善细节）<br>嗯，发现可以做，要做的事有好多好多，多想能活500年哇<br>慢慢来吧，先把blog捡起来。。。。。<br>把 hexo 的坑统一汇总下，之前搞懂了又忘了。。。。。</p></blockquote><h2 id="hexo-简介"><a href="#hexo-简介" class="headerlink" title="hexo 简介"></a>hexo 简介</h2><p><strong>写blog的神器，看中了他兼容markdown语法且github托管</strong><br>hexo基于nodejs，将markdown可以直接编译成html，同时支持直接托管到github上，所以hexo的包管理均由npm管理。<br>hexo托管git需要绑定name.github.io的仓库，托管后改仓库的master即为编译后的html文件。</p><h4 id="环境保存方案"><a href="#环境保存方案" class="headerlink" title="环境保存方案"></a>环境保存方案</h4><p>name.github.io 代码库 新建一个分支，存储所有文件，提交。<br>所以仓库结构就是</p><ul><li>master 托管 编译完的html文件，由<strong>hexo命令</strong>管理</li><li>新建分支托管其他所有文件，有<strong>git命令</strong>管理</li></ul><h2 id="命令相关"><a href="#命令相关" class="headerlink" title="命令相关"></a>命令相关</h2><h3 id="hexo-1"><a href="#hexo-1" class="headerlink" title="hexo"></a>hexo</h3><ol><li>清理本地空间 <code>hexo clean</code></li><li>编译生成html <code>hexo g</code></li><li>本地服务 <code>hexo s</code></li><li>发布托管到git <code>hexo d</code></li><li>一键部署命令(编译并发布) <code>hexo g -d</code></li></ol><h3 id="npm包管理"><a href="#npm包管理" class="headerlink" title="npm包管理"></a>npm包管理</h3><ol><li>检测本地js包情况 <code>npm ls --depth 0</code></li><li>下载安装 <code>npm install packagename --save</code></li><li>检测项目依赖中的漏洞并自动安装 <code>npm audit fix</code></li></ol><h2 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h2><h3 id="git-提交失败"><a href="#git-提交失败" class="headerlink" title="git 提交失败"></a>git 提交失败</h3><p><strong>https 改为 git模式push</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;hexo&quot;&gt;&lt;a href=&quot;#hexo&quot; class=&quot;headerlink&quot; title=&quot;hexo&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="技术" scheme="http://sevjoker.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="blog" scheme="http://sevjoker.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>golang踩坑</title>
    <link href="http://sevjoker.github.io/2019/04/21/golang%E8%B8%A9%E5%9D%91/"/>
    <id>http://sevjoker.github.io/2019/04/21/golang踩坑/</id>
    <published>2019-04-20T17:54:02.000Z</published>
    <updated>2019-10-13T14:05:40.629Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --><h1 id="golang-线上问题汇总"><a href="#golang-线上问题汇总" class="headerlink" title="golang 线上问题汇总"></a>golang 线上问题汇总</h1><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><blockquote><p>线上cpu不定时抖动</p></blockquote><h3 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h3><blockquote><p>大量go协程启用了NewTicker 而未主动关闭，而ticker对象会默认存储在一个最小堆上，todo</p></blockquote><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><ul><li>time.After vs time.NewTicker 区分使用</li></ul><h2 id="concurrent-map-iteration-and-map-write"><a href="#concurrent-map-iteration-and-map-write" class="headerlink" title="concurrent map iteration and map write"></a>concurrent map iteration and map write</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><blockquote><p>线上服务直接崩溃</p></blockquote><h3 id="问题发现-1"><a href="#问题发现-1" class="headerlink" title="问题发现"></a>问题发现</h3><blockquote><p>并发读写map引起<br>不是一个panic 无法被 recover<br>This means that the Go runtime may detect if a map is read or modified in a goroutine, and it is also modified by another goroutine, concurrently, without synchronization.</p></blockquote><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><blockquote><p>锁处理<br>sync.Map</p></blockquote><h3 id="问题衍生"><a href="#问题衍生" class="headerlink" title="问题衍生"></a>问题衍生</h3><ul><li>当一个 map被json encode时也会导致此问题（等同于读操作）</li></ul><h3 id="问题复原及深究"><a href="#问题复原及深究" class="headerlink" title="问题复原及深究"></a>问题复原及深究</h3><h5 id="单层map"><a href="#单层map" class="headerlink" title="单层map"></a>单层map</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line">var m = make(map[string]string) //wrong</span><br><span class="line">var sm = &amp;sync.Map&#123;&#125; // right</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    sm.Store(&quot;x&quot;,&quot;aaa&quot;)</span><br><span class="line">    m[&quot;x&quot;] = &quot;aaa&quot;</span><br><span class="line">    sm.Store(&quot;x&quot;, m)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err1 := recover(); err1 != nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        for &#123;</span><br><span class="line">            m[&quot;x&quot;] = &quot;xxxx&quot;</span><br><span class="line">            // sm.Store(&quot;x&quot;,&quot;bbbb&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err1 := recover(); err1 != nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        for &#123;</span><br><span class="line">            _ = m[&quot;x&quot;]</span><br><span class="line">            // v,ok := sm.Load(&quot;x&quot;)</span><br><span class="line">            // sm.Store(&quot;x&quot;,&quot;bbbb&quot;)</span><br><span class="line">            // fmt.Println(v,ok)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    fmt.Println(&quot;----&quot;)</span><br><span class="line">    time.Sleep(1 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当写map时 无论并发去读还是去写都会fatal 且无法被捕获<br>可用sync.Map 绝对安全</p></blockquote><h4 id="多层map"><a href="#多层map" class="headerlink" title="多层map"></a>多层map</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    // &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type AA struct &#123;</span><br><span class="line">    mu *sync.Mutex</span><br><span class="line">    aa map[string]map[string]int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *AA)set(b int) &#123;</span><br><span class="line">    a.mu.Lock()</span><br><span class="line">    defer a.mu.Unlock()</span><br><span class="line">    a.aa[&quot;aaa&quot;][&quot;aaa&quot;] = b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *AA)get() map[string]int &#123;</span><br><span class="line">    a.mu.Lock()</span><br><span class="line">    defer a.mu.Unlock()</span><br><span class="line">    return a.aa[&quot;aaa&quot;]    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sm = &amp;sync.Map&#123;&#125; </span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    sm.Store(&quot;aaa&quot;,map[string]string&#123;&quot;aaa&quot;:&quot;aaa&quot;&#125;)</span><br><span class="line">    // a := &amp;AA&#123;aa:map[string]map[string]int&#123;&quot;aaa&quot;:map[string]int&#123;&quot;aaa&quot;:1&#125;&#125;,mu:new(sync.Mutex)&#125; </span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err1 := recover(); err1 != nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        for &#123;</span><br><span class="line">            // a.set(123)</span><br><span class="line">            v,_ := sm.Load(&quot;aaa&quot;)</span><br><span class="line">            v1 := v.(map[string]string)</span><br><span class="line">            // fmt.Println(v,v1,ok)</span><br><span class="line">            v1[&quot;aaa&quot;] = &quot;bbb&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    go func() &#123;</span><br><span class="line">        if err1 := recover(); err1 != nil &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        for &#123;</span><br><span class="line">            // v := a.get()</span><br><span class="line">            // _ = v[&quot;aaa&quot;]</span><br><span class="line"></span><br><span class="line">            // v,ok := sm.Load(&quot;x&quot;)</span><br><span class="line">            // sm.Store(&quot;x&quot;,&quot;bbbb&quot;)</span><br><span class="line">            // fmt.Println(v,ok)</span><br><span class="line"></span><br><span class="line">            v,_ := sm.Load(&quot;aaa&quot;)</span><br><span class="line">            v1 := v.(map[string]string)</span><br><span class="line">            // _ = v1[&quot;&quot;]</span><br><span class="line">            _ = v1[&quot;aaa&quot;]</span><br><span class="line">            // fmt.Sprintln(&quot;111&quot;,v1)</span><br><span class="line">            // fmt.Println(v,v1,ok)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(10 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>多层map 无论是锁还是sync.Map都无可避免的会出现将底层的map句柄暴露给上层，继而引发同时读写错误</p></blockquote><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><blockquote><p>当你操作的map可能存在同时读写的情况下就必须加锁<br>读写操作必须都加锁<br>即 存在数据竞争的map引用不可暴露给上层</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --&gt;&lt;h1 id=&quot;golang-线上问题汇总&quot;&gt;&lt;a href=&quot;#golang-线上问题汇总&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="技术" scheme="http://sevjoker.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="golang" scheme="http://sevjoker.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>开卷有益</title>
    <link href="http://sevjoker.github.io/2019/04/14/first/"/>
    <id>http://sevjoker.github.io/2019/04/14/first/</id>
    <published>2019-04-13T16:27:46.000Z</published>
    <updated>2019-10-13T14:10:59.058Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --><h2 id="随便记点啦"><a href="#随便记点啦" class="headerlink" title="随便记点啦"></a>随便记点啦</h2><blockquote><p>好记忆不如烂笔头 何况如此懒得记东西的我</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hello blog!</span><br></pre></td></tr></table></figure><h3 id="立个flag"><a href="#立个flag" class="headerlink" title="立个flag"></a>立个flag</h3><ol><li>每月至少一篇blog (all type)</li><li>good good study, day day up</li><li>you need to know what are you doing ha~</li></ol><h2 id="打卡"><a href="#打卡" class="headerlink" title="打卡"></a>打卡</h2><h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a>健身</h3><ul><li>2019-04-20</li></ul><h3 id="LOL"><a href="#LOL" class="headerlink" title="LOL"></a>LOL</h3><ul><li>2019-04-20</li><li>2019-04-25</li><li>2019-05-01</li><li>2019-10-08</li><li>2019-10-09</li></ul><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><ul><li>2019-04-22 golang deadline 寻密</li></ul><h3 id="鸡汤"><a href="#鸡汤" class="headerlink" title="鸡汤"></a>鸡汤</h3><ul><li>没有人会为你真正的价值买单，他们只会为他们所认为的你的价值买单</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Oct 14 2019 00:14:25 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;随便记点啦&quot;&gt;&lt;a href=&quot;#随便记点啦&quot; class=&quot;headerlink&quot; title=&quot;随便记点啦&quot;&gt;
      
    
    </summary>
    
      <category term="随便记" scheme="http://sevjoker.github.io/categories/%E9%9A%8F%E4%BE%BF%E8%AE%B0/"/>
    
    
      <category term="随记" scheme="http://sevjoker.github.io/tags/%E9%9A%8F%E8%AE%B0/"/>
    
  </entry>
  
</feed>
